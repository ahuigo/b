<!DOCTYPE html>
<html lang="zh-cn">
<head>
<script>
if(!('noModule' in HTMLScriptElement.prototype)){
alert('你的浏览器不能很好的支持 es6，请用最新的chrome、firefox浏览!')
}
const MD_URL='post/go/16.go-func.md';
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1" />
<title>Golang func</title>
<meta name="author" content="ahuigo">
<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css">
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-router@3.0.1/dist/vue-router.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.3/dist/Valine.min.js"></script>
</head>
<body class="layout-documentation page-layout">
<div id="app">
<div :id="'imgview'" v-if="imgsrc" @click="imgsrc=null"><div class="popup-back"></div><div class="img-wrapper"><img :src="imgsrc"></div></div>
<div class="pure-menu pure-menu-horizontal">
<div>
<ul class="pure-menu-list">
<li class="pure-menu-item">
<div class="menu-toggle" :class="{a:true}" @click="showMenu=!showMenu">
</div>
</li>
<li class="pure-menu-item"><a href="//github.com/ahuigo">AHUIGO</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/b/index.html">Home</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="//github.com/ahuigo">Github</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/b/atom.xml">Rss</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/a#/README.md">Readme</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/a/demo/fiddle/fiddle.html">Fiddle</a></li>
</ul>
</div>
</div>
<div class="main">
<div :class="{left:true, 'active':showMenu}" >
<tree-folder :nodes="nodes" :class="{'active':showMenu}" :show="show"></tree-folder>
</div>
<div class="middle" v-on="showMenu?{click:r=>showMenu=false}:{}">
<router-view></router-view>
<pre id="markdown" v-pre>---
title: Golang func
date: 2018-09-27
updated: 2019-01-07
---
# Golang func
func 是func-value

# Function Closures
https://stackoverflow.com/questions/21961615/why-doesnt-go-allow-nested-function-declarations-functions-inside-functions

直接定义inner function 是不行的, 除了匿名函数随便生成：

    inc := func(x int) int { return x+1; }
    return func(x int) int { return x+1; }

A closure is a function value that references variables from outside its body.

	func adder() func(int) int {
		sum := 0
		return func(x int) int {
			sum += x
			return sum
		}
	}

	func main() {
		pos, neg := adder(), adder()
		for i := 0; i &lt; 10; i++ {
			fmt.Println(
				pos(i),
				neg(-2*i),
			)
		}
	}

## number of arguments, 不定参数
	func sum(nums ...int) {
	    fmt.Printf(&quot;%T&quot;,nums)  //slice = []int{1, 2, 3)
	}
	sum(1, 2, 3)

any type: interface{}

	func Statusln(a ...interface{})
	a := []interface{}{&quot;hello&quot;, &quot;world&quot;, 42}


## Multiple results
A function can return any number of results.

	func swap(x, y string) (string, string) {
		return y, x
	}
	a, b := swap(&quot;hello&quot;, &quot;world&quot;)
	a, _ := swap(&quot;hello&quot;, &quot;world&quot;)

### Named return values
A return statement `without` arguments returns the `named return values`.
This is known as a `&quot;naked&quot;` return.

	func split(sum int) (x, y int) {
		x = sum * 4 / 9
		y = sum - x
		return
	}
    x,y:=split(17)
	fmt.Println(split(17))

## Short variable declarations
Inside a function, the `:=` short assignment statement can be used in place of `a var declaration` with `implicit type`.
&gt; Outside a function, every statement begins with a `keyword (var, func, and so on)` and so the `:=` construct is not available.

	func main() {
		var i, j int = 1, 2
		k := 3
		c, python, java := true, false, &quot;no!&quot;

		fmt.Println(i, j, k, c, python, java)
	}

# Methods
Go does not have classes. However, you can define methods with a special receiver argument.
The receiver appears in its `own argument list` between the `func keyword` and the `method name`.

	type Vertex struct {
		X, Y float64
	}

	func (v Vertex) Abs() float64 {
		return math.Sqrt(v.X*v.X + v.Y*v.Y)
	}

	func main() {
		v := Vertex{3, 4}
		fmt.Println(v.Abs())
	}

## Mehtond on local-type
Declare a method on non-struct types, such as float64

	type MyFloat float64

	func (f MyFloat) Abs() float64 {
		if f &lt; 0 {
			return float64(-f)
		}
		return float64(f)
	}

	func main() {
		f := MyFloat(-math.Sqrt2)
		fmt.Println(f.Abs())
	}

You can only declare:
1. a method with a receiver whose **type** is **defined in the same package** as the method.
2. You cannot declare a method with a receiver whose type is defined in another package (such as the built-in types: int float64).

## methods with pointer receivers.
If you wanna change receivers, use pointer pls.

	type Vertex struct {
		X, Y float64
	}

	func (v Vertex) Abs() float64 {
		return math.Sqrt(v.X*v.X + v.Y*v.Y)
	}

    // Pointer 指针，而不是copy
	func (v *Vertex) Scale(f float64) {
		v.X = v.X * f
		v.Y = v.Y * f
	}

	func main() {
		v := Vertex{3, 4}
		v.Scale(10)
		fmt.Println(v.Abs())
	}

### pointer as arg

	func Abs(v )
	Abs(&amp;v)

since the Scale method has a pointer receiver and `v is not pointer`

	var v Vertex
	v.Scale(5)  // OK. as (&amp;v).Scale(5) since the Scale method has a pointer receiver.
	p := &amp;v
	p.Scale(10) // OK

the method call `p.Abs()` is interpreted as `(*p).Abs()`.

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &amp;v
	fmt.Println(p.Abs()) // OK interpreted as `(*p).Abs()`.

# Errors
The error type is a built-in interface similar to fmt.Stringer:
error类型本身就是一个预定义好的接口，里面定义了一个method

	type error interface {
	    Error() string
	}

	nil
	io.EOF

## 方式1：errrors.New

    import &quot;errors&quot;
    func main() {
        var err error = errors.New(&quot;this is a new error&quot;)
        var EOF = errors.New(&quot;EOF&quot;)
        fmt.Println(EOF.Error(), err.Error())
        fmt.Println(EOF, err)

    }

## 方式2： fmt.Errorf
    err = fmt.Errorf(&quot;%s&quot;, &quot;the error test for fmt.Errorf&quot;)
    fmt.Println(err.Error())

## custom MyError
方式3: 自定义Customeror 结构体和Error(): 

	type MyError struct {
		When time.Time
		What string
	}

	func (e *MyError) Error() string {
		return fmt.Sprintf(&quot;at %v, %s&quot;,
			e.When, e.What)
	}

	func run() (string, error) {
		return &quot;results!!&quot;, &amp;MyError{
			time.Now(),
			&quot;it didn&#x27;t work&quot;,
		}
	}

	func main() {
		if ret, err := run(); err != nil {
			fmt.Println(ret,err)
		}
	}

# 参数

## 默认参数, Optional Parameters
    func foo(params ...int) {
        fmt.Println(len(params))
    }

    func main() {
        foo()
        foo(1)
        foo(1,2,3)
    }

# Panic
相当于 php 的 die, 但是可以通过 defer 被 recovery 捕获:

	func g(i int) {
		 fmt.Println(&quot;Panic!&quot;)
		 panic(fmt.Sprintf(&quot;%v&quot;, i))
	}

	func f() {
		 defer func() {
				 if r := recover(); r != nil {
						 fmt.Println(&quot;Recovered in f&quot;, r)
				 }
		 }()

		i := 10
		fmt.Println(&quot;Calling g with &quot;, i)
		g(i)
		fmt.Println(&quot;Returned normally from g.&quot;)
	}</pre>
<div id="pager"></div>
<div class="hr"></div>
<div class="share" style="display:flex;justify-content:space-between">
<div>
<h4>关注我</h4>
<div>
<iframe width="120" height="22" :src="`https://platform.twitter.com/widgets/follow_button.4a8202e5fcbfb5ba8d36683841f4d020.en.html#screen_name=${config.twitter_user}&width=67&height=22&show_count=false&show_screen_name=true`"></iframe>
<iframe width="120" height="22" :src="`https://widget.weibo.com/relationship/followbutton.php?btn=light&style=1&uid=${config.weibo_uid}&width=67&height=22&language=zh_cn`"></iframe>
</div>
</div>
<div>
<h4>分享文章</h4>
<div>
<span class="icon twitter-icon" @click="openShare('twitter', this)"></span>
<span class="icon weibo-icon" @click="openShare('weibo')"></span>
</div>
</div>
</div>
<div class="hr"></div>
<div id="comments"></div>
</div>
<div class="right">
<div id="toc"><ol><li>笔记</li><ol></div>
<div id="search" class="pure-form">
<fieldset>
<input id="search_q" placeholder="Google" @keyup.enter="searchBlog($('#search_q').value)">
<button @click="searchBlog($('#search_q').value)" class="pure-button pure-button-primary">搜索</button>
</fieldset>
</div>
</div>
</div>
<button class="button is-primary" onclick="window.scroll(0, 10)" id="up">Up</button>
<button class="button is-primary" onclick="window.scrollTo(0,document.body.scrollHeight)" id="down">Down</button>
</div>
<template id="tree-folder">
<ul class="pure-menu-list" v-if="show">
<li class="pure-menu-item" v-for="(file,index) in nodes" :key="file.path">
<a v-if="file.type==='dir'" :type="file.type" @click="openFolder(file)" class="folder">{{file.name}}
</a>
<a v-else :type="file.type" class="file" :href="('/'+file.path).replace(/^\/post\b/, '/b').slice(0,-3)">{{file.name.slice(0,-3)}} </a>
<tree-folder v-if="file.nodes" :show="file.show" :nodes="file.nodes"></tree-folder>
</li>
</ul>
</template>
<template id="md">
<div id="content" v-html="marked(md)"></div>
</template>
<link href="/b/../a/css/main2.css" rel="stylesheet" async>
<script src="/b/js/marked.js"></script>
<script src="/b/js/toc.js"></script>
<script src="/b/../a/js/blog2.js"></script>
</body>
</html>
