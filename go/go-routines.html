<!DOCTYPE html>
<html lang="zh-cn">
<head>
<script>
if(!('noModule' in HTMLScriptElement.prototype)){
alert('你的浏览器不能很好的支持 es6，请用最新的chrome、firefox浏览!')
}
const MD_URL='post/go/go-routines.md';
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1" />
<title>go routines</title>
<meta name="author" content="ahuigo">
<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css">
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-router@3.0.1/dist/vue-router.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.3/dist/Valine.min.js"></script>
<link href="/b/../a/css/main2.css" rel="stylesheet">
<script src="/b/../a/js/marked.js"></script>
<script src="/b/../a/js/toc.js"></script>
</head>
<body class="layout-documentation page-layout">
<div id="app">
<div :id="'imgview'" v-if="imgsrc" @click="imgsrc=null"><img :src="imgsrc"></div>
<div class="pure-menu pure-menu-horizontal">
<div>
<ul class="pure-menu-list">
<li class="pure-menu-item">
<div class="menu-toggle" :class="{a:true}" @click="showMenu=!showMenu">
</div>
</li>
<li class="pure-menu-item"><a href="//github.com/ahuigo">AHUIGO</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/b/index.html">Home</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/b/atom.xml">Rss</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/a#/README.md">Readme</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/a/demo/fiddle/fiddle.html">Fiddle</a></li>
</ul>
</div>
</div>
<div class="main">
<div :class="{left:true, 'active':showMenu}" >
<tree-folder :nodes="nodes" :class="{'active':showMenu}" :show="show"></tree-folder>
</div>
<div class="middle" v-on="showMenu?{click:r=>showMenu=false}:{}">
<router-view></router-view>
<pre id="markdown" v-pre>---
title: go routines
date: 2018-09-27
updated: 2018-10-06
---
# go routines
A goroutine is a `lightweight thread` managed by the Go runtime.

The evaluation of f, x, y, and z happens in the current goroutine and the execution of f happens in the new goroutine.

  go f(x, y, z)

## concurrency
goroutine is base on thread, 不过默认情况下goroutine 不会同时执行
如果你要真正的并发，你需要在你的main函数的第一行加上下面的这段代码：

  import &quot;runtime&quot;
  ...
  runtime.GOMAXPROCS(4);// 4核

并发有安全问题:

  var total_tickets int32 = 10;

  func sell_tickets(i int){
    for{
        if total_tickets &gt; 0 { //如果有票就卖
            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)
            total_tickets-- //卖一张票
            fmt.Println(&quot;id:&quot;, i, &quot;  ticket:&quot;, total_tickets)
        }else{
            break
        }
    }
  }

  func main() {
    runtime.GOMAXPROCS(4) //我的电脑是4核处理器，所以我设置了4
    rand.Seed(time.Now().Unix()) //生成随机种子

    for i := 0; i &lt; 5; i++ { //并发5个goroutine来卖票
         go sell_tickets(i)
    }
    //等待线程执行完
    var input string
    fmt.Scanln(&amp;input)
    fmt.Println(total_tickets, &quot;done&quot;) //退出时打印还有多少票
  }

避免并发, 使用mutex 保证`total_tickets &gt; 0 &amp;&amp; total_tickets--` 构成原子性:

  mutex.Lock()
  mutex.UnLock()

## goroutine 实现
https://www.zhihu.com/question/20862617

## atomic
不加 atomic 那 cnt 可能会小于200, 它保证`cnt = cnt + value` 变成 atomic

  import &quot;fmt&quot;
  import &quot;time&quot;
  import &quot;sync/atomic&quot;

  func main() {
      var cnt uint32 = 0
      for i := 0; i &lt; 10; i++ {
          go func() {
              for i:=0; i&lt;20; i++ {
                  time.Sleep(time.Millisecond)
                  atomic.AddUint32(&amp;cnt, 1)
              }
          }()
      }
      time.Sleep(time.Second)//等一秒钟等goroutine完成
      cntFinal := atomic.LoadUint32(&amp;cnt)//取数据
      fmt.Println(&quot;cnt:&quot;, cntFinal)
  }

## routines&#x27;s features:

1. Same Address Space:
  Goroutines run in the same address space, so access to shared memory must be synchronized.
2. Sync:
  The `sync` package provides useful primitives, although you won&#x27;t need them much in Go as there are other primitives.

# channel
Like maps and slices, channels must be created before use:

  ch := make(chan int)

Channels are a typed conduit through which you can send and receive values with the channel operator, `&lt;-`.

  ch &lt;- v    // Send v to channel ch.
  v := &lt;-ch  // Receive from ch, and
             // assign value to v.

## block channel with routines
By default, sends and receives block until the *other side is ready*.
This allows goroutines to synchronize without explicit locks or condition variables.

  func sum(s []int, c chan int) {
  	sum := 0
  	for _, v := range s {
  		sum += v
  	}
  	c &lt;- sum // send sum to c
  }

  func main() {
  	s := []int{7, 2, 8, -9, 4, 0}

  	c := make(chan int)
  	go sum(s[:len(s)/2], c)
  	go sum(s[len(s)/2:], c)
  	x, y := &lt;-c, &lt;-c // receive from c

  	fmt.Println(x, y, x+y)
  }
  a_

## buffer channel
Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:

  ch := make(chan int, 100)

Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.

  ch := make(chan int, 2)
	ch &lt;- 1
	ch &lt;- 2
	fmt.Println(&lt;-ch)
	fmt.Println(&lt;-ch)

## close channel
A sender could close channel, receiver can test whether a channel is closed.

  ch := make(chan int)
  close(ch)
  v, ok := &lt;-ch

`ok == false` if there are no more values.

`for i := range c` receives values from channel repeatedly until `it is closed`

&gt; `Sending on a closed channel` will cause a `panic`.
&gt; Closing is only necessary when the receiver must be told there are no more values that is coming, such as terminate `range loop`

# select
The select statement lets a goroutine `wait` on multiple communication operators
The select blocks until on of its case can run, then execute it.(choose on random if multiple are ready)

  func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
      select {
      case c &lt;- x:
        x, y = y, x+y
      case &lt;-quit:
        fmt.Println(&quot;quit&quot;)
        return
      }
    }
  }

  func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
      for i := 0; i &lt; 10; i++ {
        fmt.Println(&lt;-c)
      }
      quit &lt;- 0
    }()
    fibonacci(c, quit)
  }

## default selection
The default case in a slect is run if no other case is ready

  tick := time.Tick(100 * time.Millisecond)
  boom := time.After(500 * time.Millisecond)
  for {
    select {
    case &lt;-tick:
      fmt.Println(&quot;tick.&quot;)
    case &lt;-boom:
      fmt.Println(&quot;BOOM!&quot;)
      return
    default:
      fmt.Println(&quot;    .&quot;)
      time.Sleep(50 * time.Millisecond)
    }
  }

## channel 无阻塞
一般有两种方法：一种是阻塞但有timeout，一种是无阻塞。我们来看看如果给select设置上timeout的。

### Channel select阻塞的Timeout

  for {
      timeout_cnt := 0
      select {
      case msg1 := &lt;-c1:
          fmt.Println(&quot;msg1 received&quot;, msg1)
      case msg2 := &lt;-c2:
          fmt.Println(&quot;msg2 received&quot;, msg2)
      case  &lt;-time.After(time.Second * 30)：
          fmt.Println(&quot;Time Out&quot;)
          timout_cnt++
      }
      if time_cnt &gt; 3 {
          break
      }
  }

### Channel的无阻塞

  for {
      select {
      case msg1 := &lt;-c1:
          fmt.Println(&quot;received&quot;, msg1)
      case msg2 := &lt;-c2:
          fmt.Println(&quot;received&quot;, msg2)
      default: //default会导致无阻塞
          fmt.Println(&quot;nothing received!&quot;)
          time.Sleep(time.Second)
      }
  }

# sync.Mutex
mutex 互斥: mutual exclusion 相互排斥
go provides mutual exclusion with sync.Mutex and its two methods:

  Lock
  Unlock

We can also use defer to ensure the mutex will be unlocked as in the Value method.

  // SafeCounter is safe to use concurrently.
  type SafeCounter struct {
  	v   map[string]int
  	mux sync.Mutex
  }

  // Inc increments the counter for the given key.
  func (c *SafeCounter) Inc(key string) {
  	c.mux.Lock()
  	// Lock so only one goroutine at a time can access the map c.v.
  	c.v[key]++
  	c.mux.Unlock()
  }

  // Value returns the current value of the counter for the given key.
  func (c *SafeCounter) Value(key string) int {
  	c.mux.Lock()
  	// Lock so only one goroutine at a time can access the map c.v.
  	defer c.mux.Unlock()
  	return c.v[key]
  }

  func main() {
  	c := SafeCounter{v: make(map[string]int)}
  	for i := 0; i &lt; 1000; i++ {
  		go c.Inc(&quot;somekey&quot;)
  	}

  	time.Sleep(time.Second)
  	fmt.Println(c.Value(&quot;somekey&quot;))
  }
  a*</pre>
<div id="pager" v-pre></div>
<div class="hr"></div>
<div class="share" style="display:flex;justify-content:space-between">
<div>
<h4>关注我</h4>
<div>
<iframe width="120" height="22" :src="`https://platform.twitter.com/widgets/follow_button.4a8202e5fcbfb5ba8d36683841f4d020.en.html#screen_name=${config.twitter_user}&width=67&height=22&show_count=false&show_screen_name=true`"></iframe>
<iframe width="120" height="22" :src="`https://widget.weibo.com/relationship/followbutton.php?btn=light&style=1&uid=${config.weibo_uid}&width=67&height=22&language=zh_cn`"></iframe>
</div>
</div>
<div>
<h4>分享文章</h4>
<div>
<span class="icon twitter-icon" @click="openShare('twitter', this)"></span>
<span class="icon weibo-icon" @click="openShare('weibo')"></span>
</div>
</div>
</div>
<div class="hr"></div>
<div id="comments"></div>
</div>
<div class="right">
<div id="toc"></div>
<div id="search" class="pure-form">
<fieldset>
<input id="search_q" @keyup.enter="searchBlog($('#search_q').value)">
<button @click="searchBlog($('#search_q').value)" class="pure-button pure-button-primary">搜索</button>
</fieldset>
</div>
</div>
</div>
<button class="button is-primary" onclick="window.scroll(0, 10)" id="up">Up</button>
<button class="button is-primary" onclick="window.scrollTo(0,document.body.scrollHeight)" id="down">Down</button>
</div>
<template id="tree-folder">
<ul class="pure-menu-list" v-if="show">
<li class="pure-menu-item" v-for="(file,index) in nodes" :key="file.path">
<a v-if="file.type==='dir'" :type="file.type" @click="openFolder(file)" class="folder">{{file.name}}
</a>
<a v-else :type="file.type" class="file" :href="('/'+file.path).replace(/^\/post\b/, '/b').slice(0,-3)">{{file.name.slice(0,-3)}} </a>
<tree-folder v-if="file.nodes" :show="file.show" :nodes="file.nodes"></tree-folder>
</li>
</ul>
</template>
<template id="md">
<div id="content" v-html="marked(md)"></div>
</template>
<script src="/b/../a/js/blog2.js"></script>
</body>
</html>
