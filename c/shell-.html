<!DOCTYPE html>
<html lang="zh-cn">
<head>
<script>
if(!('noModule' in HTMLScriptElement.prototype)){
alert('你的浏览器不能很好的支持 es6，请用最新的chrome、firefox浏览!')
}
const MD_URL='post/c/shell-.md';
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1" />
<title>Shell Programming</title>
<meta name="author" content="ahuigo">
<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css">
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-router@3.0.1/dist/vue-router.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.3/dist/Valine.min.js"></script>
<link href="/b/../a/css/main2.css" rel="stylesheet">
<script src="/b/../a/js/marked.js"></script>
<script src="/b/../a/js/toc.js"></script>
</head>
<body class="layout-documentation page-layout">
<div id="app">
<div :id="'imgview'" v-if="imgsrc" @click="imgsrc=null"><img :src="imgsrc"></div>
<div class="pure-menu pure-menu-horizontal">
<div>
<ul class="pure-menu-list">
<li class="pure-menu-item">
<div class="menu-toggle" :class="{a:true}" @click="showMenu=!showMenu">
</div>
</li>
<li class="pure-menu-item"><a href="//github.com/ahuigo">AHUIGO</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/b/index.html">Home</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/b/atom.xml">Rss</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/a#/README.md">Readme</a></li>
<li class="pure-menu-item"><a class="button is-primary" href="/a/demo/fiddle/fiddle.html">Fiddle</a></li>
</ul>
</div>
</div>
<div class="main">
<div :class="{left:true, 'active':showMenu}" >
<tree-folder :nodes="nodes" :class="{'active':showMenu}" :show="show"></tree-folder>
</div>
<div class="middle" v-on="showMenu?{click:r=>showMenu=false}:{}">
<router-view></router-view>
<pre id="markdown" v-pre>---
title: Shell Programming
date: 2014-03-05
updated: 2018-10-06
---
# Shell Programming

# Variable

	let num++
	let ++num

	declare -i num
	num+=1

	((num++))

## readonly

	x=6
	readonly x

## 输出变量

	echo $v
	echo ${v}

### bash 中的换行
建议使用zsh. 因为bash不会将单双引号中的`\n`解析为换行.

	echo &quot;a\nb&quot; #bash 不换行,\n会被原样输出
	echo $&#x27;a\nb&#x27; #这样才能换行

&gt; 如果需要\n换行, 建议使用zsh 或者 printf &#x27;a\nb %s&#x27; $str

## shell 特殊变量

	$$     脚本运行的当前进程的ID号
	$!     *后台运行*的最后一个进程的ID号
	$#     传递到脚本的参数个数
	$@   	传递给脚本的参数数组
	$*   	传递给脚本的参数字符串
	$-     显示shell使用的当前选项
	$?     显示最后命令的退出状态，0表示无错误
	$0 		Current Process&#x27;s ScriptPath
	$PWD	`pwd`
	$UID
	$USER
	$RANDOM 随机数
	$COLUMNS $LINES only for zsh

### PS1

	PS1 命令提示符
	PS1=&#x27;\[\e[1;31m\][\u@\W]\$\[\e[m\]&#x27; #\[\e[1;31m\] 是红色粗体, \[\e[m\] 是正常颜色值.

### Get Script pid
&gt; http://wiki.jikexueyuan.com/project/13-questions-of-shell/exec-source.html

- fork 子进程
- exec 替换当前进程的code(原有程序终止)
- source 在前进程执行code

### Get Script File Path
In bash(&gt;=3):

	$0				Current Process&#x27;s Path
	BASH_SOURCE[0]	Current Script&#x27;s Path

In zsh:

	$0				Current Script&#x27;s Path

Working Directory:

	pwd

Example:

	$ cat s.sh
	#!/bin/bash
	printf &#x27;$0 is: %s\n $BASH_SOURCE is: %s\n&#x27; &quot;$0&quot; &quot;$BASH_SOURCE&quot;

	bash-3.2$ ./s.sh
		$0 is: ./s.sh,$BASH_SOURCE is: ./s.sh
	bash-3.2$ source s.sh
		$0 is: bash,$BASH_SOURCE is: s.sh

## 赋值

	v=value #注意=两边不能有空格,这是规定!
	unset v ;#删除字符串

### read 交互

	read [-pt] [variable]
	read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name name2...]
	选项与参数：
	-p  ：后面可以接提示字符！
	-t  ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者啦！
	variable
		默认是REPLY

	## read line
	while read line;
	do
		echo $line
	done &lt; file

	## read line from string
	while read line; do echo $i; done &lt;  &lt;(
		cat&lt;&lt;MM
		124.104.141.23:80
		82.165.135.253:3128
		MM
	)

read without echoing

	read -s var

multiple and line:

	bash-3.2$ read a
	1 2
	bash-3.2$ echo $a
	1 2
	bash-3.2$ read a b c
	1 2
	bash-3.2$ echo $a
	1
	bash-3.2$ echo $b
	2
	bash-3.2$ echo $c

### 声明

	 declare [-aixr] variable
	 typeset [-aixr] variable

	 选项与参数：
	 -a  ：将后面名为 variable 的变量定义成为数组 (array) 类型
	 -i  ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型
	 -x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；
	 -r  ：将变量配置成为 readonly 类型，该变量不可被更改内容，也不能 unset
	 declare -p var  #单独列出变量类型

	unset var #销毁变量

##  环境变量

	env #查看环境变量 与说明
	env var1=1 var2=2 php -r &#x27;var_dump($_SERVER);&#x27;  #执行其它信命令时, 指定子进程的环境变量
	set #查看环境变量与自定义变量.
	export  #查看环境变量的生成语句(declare -x)

## 环境配置stty,set

### set
一般地，set 的参数如果以- 为前缀，则表示设置；如果以`+`为前缀，表示取消.

	set # 查看/设置 环境变量与本地变量
	set -x # set -o xtrace 执行时打印语句
	set +x # 执行时不打印语句
	set -e # set -o errexit

	set -o :
		emacs/vi			在进行命令编辑的时候,使用内建的emacs编辑器, 默认选项
		errexit		-e		非0退出状态值(失败),就退出. 判断条件(if/&amp;&amp;/||)中子命令的状态码则没有影响
		xtrace		-x		打开调试回响模式
		verbose		-v		为调试打开verbose模式
		nounset		#		引用未定义的变量(缺省值为&quot;&quot;)
		allexport	-a		从设置开始标记所有新的和修改过的用于输出的变量
		braceexpand	-B		允许符号扩展,默认选项
		histexpand	-H		在做临时替换的时候允许使用!和!! 默认选项
		history				允许命令行历史,默认选项
		ignoreeof			禁止coontrol-D的方式退出shell，必须输入exit。
		interactive-comments		在交互式模式下， #用来表示注解
		keyword		-k		为命令把关键字参数放在环境中
		monitor		-m		允许作业控制
		noclobber	-C		保护文件在使用重新动向的时候不被覆盖
		noexec		-n		在脚本状态下读取命令但是不执行，主要为了检查语法结构。
		noglob		-d		禁止路径名扩展，即关闭通配符
		notify		-b		在后台作业以后通知客户
		nounset		-u		在扩展一个没有的设置的变量的时候，    显示错误的信息
		onecmd		-t		在读取并执行一个新的命令后退出
		physical	-P		如果被设置，则在使用pwd和cd命令时不使用符号连接的路径 而是物理路径
		posix		改变shell行为以便符合POSIX要求
		privileged		一旦被设置，shell不再读取.profile文件和env文件 shell函数也不继承任何环境

		if `+o` with no option-name, a series of set commands to recreate current set options is displayed on standard output.
		if `-o` with no option-name, the values of current  options are printed.

# Signal, 信号(trap)
Refer to:
http://billie66.github.io/TLCL/book/zh/chap37.html

signal handling:

	trap argument signal [signal...]

demo1: press`Ctrl+C` to send interrupt signal

	trap &quot;echo &#x27;I am ignoring interrupted and kill!&#x27;&quot; SIGINT SIGTERM
	for i in {1..5}; do
		echo &quot;Iteration $i of 5&quot;
		sleep 5
	done

trap-demo2 : simple signal handling demo

	exit_on_signal_SIGINT () {
		echo &quot;Script interrupted.&quot; 2&gt;&amp;1
		exit 0
	}
	exit_on_signal_SIGTERM () {
		echo &quot;Script terminated(kill).&quot; 2&gt;&amp;1
		exit 0
	}
	trap exit_on_signal_SIGINT SIGINT
	trap exit_on_signal_SIGTERM SIGTERM
	for i in {1..5}; do
		echo &quot;Iteration $i of 5&quot;
		sleep 5
	done

# Security

## temp race
给临时文件一个不可预测的文件名是很重要的。这就避免了一种为大众所知的 temp race 攻击。 一种创建一个不可预测的（但是仍有意义的）临时文件名的方法是，做一些像这样的事情：

	tempfile=/tmp/$(basename $0).$$.$RANDOM

`$$` 是pid, `$RANDOM` 的范围比较小`1-32767`.

我们可以使用`mktemp`, 它接受一个用于创建文件名的模板作为参数。这个模板应该包含一系列的 “X” 字符， 随后这些字符会被相应数量的随机字母和数字替换掉。一连串的 “X” 字符越长，则一连串的随机字符也就越长

	tempfile=$(mktemp /tmp/foobar.$$.XXXXXXXXXX) ;# /tmp/foobar.6593.UOZuvM6654

# process

## 子进程退出
shell 本身启动的`cmd &amp;`, 会随着shell 的退出而退出。
sub process 启动的`cmd &amp;`, 会随着shell 的退出, 不会退出，控制权限会被交给shell 的父进程

    `echo &quot;the command&quot;|at now`;

## async 异步执行: wait
&gt; http://billie66.github.io/TLCL/book/zh/chap37.html
wait 命令导致一个父脚本暂停运行，直到一个 特定的进程（例如，子脚本）运行结束。

	# async-parent : Asynchronous execution demo (parent)
	echo &quot;Parent: starting...&quot;
	echo &quot;Parent: launching child script...&quot;
	async-child &amp;
	pid=$!
	echo &quot;Parent: child (PID= $pid) launched.&quot;
	echo &quot;Parent: continuing...&quot;
	sleep 2
	echo &quot;Parent: pausing to wait for child to finish...&quot;
	wait $pid
	echo &quot;Parent: child is finished. Continuing...&quot;
	echo &quot;Parent: parent is done. Exiting.&quot;

`$!` shell 参数的值，它总是 包含放到*后台执行*的最后一个任务的进程 ID 号。

## check if a command exists

	hash git || { echo &#x27;Err: git is not installed.&#x27; ; exit 3; }
	command git || { echo &#x27;Err: git is not installed.&#x27; ; exit 3; }
	type git || { echo &#x27;Err: git is not installed.&#x27; ; exit 3; }

Refer to:
http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script
http://unix.stackexchange.com/questions/85249/why-not-use-which-what-to-use-then

    ➜ &gt; ~ command -v ls
    alias ls=&#x27;ls -G&#x27;
    ➜ &gt; ~ command -v go
    /usr/local/bin/go
    gopath=$(command)

## errcode
`exit 0 ` 返回一个成功的状态码，非0状态码表示不成功。

默认的管道不会传递errcode(`pipefail` is false).

	$ false | true; echo $?
	0

可以手动开启：

	$ set -o pipefail
	$ false | true; echo $?
	1

## grep &amp; ps
remove grep command while use ps

	ps aux | grep perl | grep -v grep
	ps aux | grep &#x27;[p]erl&#x27;

Or use `pgrep` instead:

	pgrep perl
	pgrep per[l]

## type
type 用于查看命令的属性

	type command
	type -t command (not support zsh)

## alias

	unalias rgrep

## exec self process

    $ bash -c &#x27;echo $$ ; ls -l /proc/self ; echo foo&#x27;
    7218
    lrwxrwxrwx 1 root root 0 Jun 30 16:49 /proc/self -&gt; 7219
    foo
    with

    $ bash -c &#x27;echo $$ ; exec ls -l /proc/self ; echo foo&#x27;
    7217
    lrwxrwxrwx 1 root root 0 Jun 30 16:49 /proc/self -&gt; 7217

## multiple command to one

    sh -c &#x27;ls ; ls&#x27;
    sh -c &#x27;cmd1 &amp;&amp; cmd2&#x27;
    sh -c &#x27;cmd1 &amp; cmd2&#x27;
    sh -c &#x27;cmd1 ; cmd2&#x27;
    sudo -- sh -c &#x27;date; who am i&#x27;

1. ampersand `&amp;` is for Asynchronous lists:
1. semi-column `;` is actually a sequential list.
2. `&amp;&amp;` is for combine cmd to one

Empty command is fobidden:

    sh -c &#x27;ls &amp; ;ls&#x27;; # syntax error

## execute command `cmd` or $(cmd)
以子进程执行cmd.(你也可通过source 以当前进程执行cmd)

	`cmd` or $(cmd)
	ls -l `locate crontab`

	source cmd or . cmd

\`\`内嵌时需要转义

	echo &quot;`ls \`which ls\``&quot;
	echo &quot;$(ls `which ls`)&quot;

&gt;	ps: a=`cmd` #如果cmd 中含有\r, 则每次\r会把前面的字符给干掉. 可以 a=`cmd | tr &quot;\r\n&quot; &quot;-+&quot;`

shell arguments:
在zsh 中会执行失败zsh为了安全，会将$var 整个字符串视为一个命令（包括其中的空白符）

	var=&#x27;svn st&#x27;; `$var`;
	var=&#x27;svn st&#x27;; $var;

你可以用eval, `sh -c`

	`eval &quot;$cmd&quot;`;
	`sh -c &quot;$cmd&quot;`;
	# 或者这样，让zsh 原样输出$var
	setopt shwordsplit; `$var`;

请参考：[Why does $var where var=&quot;foo bar&quot; not do what I expect?](http://zsh.sourceforge.net/FAQ/zshfaq03.html)

## Process Substitution - 进程替换
有些命令需要以文件名为参数(file args)，这样一来就不能使用管道。这个时候 `&lt;()` `&gt;()` 就显出用处了，它可以接受一个命令，并把它转换成临时文件名。

	# 下载并比较两个网页
	diff &lt;(wget -O - url1) &lt;(wget -O - url2)
	echo &lt;(echo &quot;foo&quot;); # ///dev/fd/17
	# 将临时文件通过管道传给命令
	wget -q -O &gt;(cat) url

	# 替换符号不分开！
	➜ &gt; py git:(gh-pages) ✗cat &lt;( echo abc )
	abc
	➜ &gt; py git:(gh-pages) ✗cat &lt; ( echo abc )
	zsh: unknown file attribute:

再来一个例子

	while read attr links owner group size date time filename; do
		cat &lt;&lt;- EOF
			Filename:     $filename
			Size:         $size
			Owner:        $owner
			Group:        $group
			Modified:     $date $time
			Links:        $links
			Attributes:   $attr
		EOF
	done &lt; &lt;(ls -l | tail -n +2)

&gt; 注意# tail -n +2, 用的+ 号哦

### pipe stdout while keeping it on screen

	#with Process Substitution
	echo abc | tee &gt;(cmd)
	#with stdout(cmd get double stdout); stdout pipe to cmd
	echo abc | tee /dev/stdout | cmd
	#with tty(screen)
	echo abc | tee /dev/tty | cmd

## heredoc and nowdoc
Act as stdin

	# heredoc 任何字词都可以当作分界符 (cat &lt; file)
	cat  &lt;&lt; MM
	echo $? #支持变量替换
	MM

	#nowdoc 加引号防止变量替换
	cat &lt;&lt; &#x27;MM&#x27; &gt; out.txt
	echo $?
	MM

	# `&lt;&lt;-` ignore tab
	if true ; then
		cat &lt;&lt;- MM | sudo tee -a file &gt; /dev/null
		The leading tab is ignored.
    MM
	fi
	# nowdoc + ignore tab(not include space) MM 仍然要顶行写
	cat &lt;&lt;-&#x27;MM&#x27; | sudo tee -a a.txt &gt; /dev/null
		echo $PATH
    MM

## here string
&gt; Note: here string 结尾会追加&#x27;\n&#x27;

Act as stdin

    python &lt;&lt;&lt;&#x27;import os;os._exit(0)&#x27;
	tr a-z A-Z &lt;&lt;&lt; &#x27;one two&#x27;
	cat &lt;&lt;&lt; &#x27;one two&#x27;

	cat &lt;&lt;&lt; $PATH a.txt
	echo &quot;$PATH&quot; | cat a.txt

Note that here string behavior can also be accomplished (reversing the order) via piping and the echo command, as in:

	echo &#x27;one two&#x27; | tr a-z A-Z

## Caculation

### expr
expr 算式:

	x=`expr $x + 1` ; #$x 与 + 与 1 之间必须有空格, 否则被expr视为字符串

### bc expression
	x=`echo $x^3 | bc`; #bc 较expr限制少, 支持大量的数学符号(而expr 仅支持+-*/%)

### let
let 数学式:

	let x=$x+1;echo $x; # let 没有返回值的

### 双括号(())
1. 支持-+*/%
2. 支持随机数

	echo $((RANDOM%100))

# debug 调试

## read args through pipe to sh

	echo &quot;echo \$@&quot; | sh -s 1 2 3
	echo &quot;echo \$@&quot; | zsh -s 1 2 3

## time

	time cmd

	$ time (for m in {1..100000}; do [[ -d . ]];done;)
	real	0m0.438s
	user	0m0.375s
	sys	0m0.063s

## Record commands and results
log command

	script [record_file]
		record_file: default typescript

Refer to: [stackoverflow](http://stackoverflow.com/questions/15698590/how-to-capture-all-the-commands-typed-in-unix-linux-by-any-user)

Also you record results via `redirection` and `exec`:

	set -x
	exec 2&gt;&gt; record.txt 1&gt;&gt;record.txt

## debug 参数
shell 支持一些调试参数：

	-n 不执行，用于检查语法错误
	-v Prints shell input lines as they are read.(set -v, set -o verbose)
	-x Print command traces before executing command.(set -x, set -o xtrace)

## 调试参数使用场景
1. 在命令行 sh -x a.sh
1. 在脚本的头部 `#/bin/sh -x`
1. 在脚本中用set 设置 `set -x` 或者 `set -o xtrace`, 用于在命令执行前打印命令


	set -x			# activate debugging from here
	w
	set +x			# stop debugging from here

# shell login

## 作为交互登录Shell启动，或者使用--login参数启动
*登录Shell*就是在输入用户名和密码*登录*后得到的Shell.  但是从*图形界面*的窗口管理器登录之后会显示桌面而不会产生登录Shell（也不会执行启动脚本），在图形界面下打开终端窗口得到的Shell也不是登录Shell。

交互式的登录shell 会依次执行:

1. /etc/profile
2. ~/.bash_profile、~/.bash_login和~/.profile三个文件中的一个
3. 退出登录时会执行~/.bash_logout脚本

## 以交互非登录Shell启动
图形界面下开一个终端窗口，或者在登录Shell提示符下再输入bash命令

1. ~/.bashrc

一般~/.bash_profile 会包含 ~/.bashrc

## 非交互Shell
为执行脚本而fork出来的子Shell是非交互Shell

# Reference
- [TLCL] The Linux Command Line book
- [shell manual] 51yip shell manual

[TLCL]: http://billie66.github.io/TLCL/book/
[shell manual]: http://manual.51yip.com/shell/
[bash 进阶]:  http://blog.sae.sina.com.cn/archives/3606
</pre>
<div id="pager" v-pre></div>
<div class="hr"></div>
<div class="share" style="display:flex;justify-content:space-between">
<div>
<h4>关注我</h4>
<div>
<iframe width="120" height="22" :src="`https://platform.twitter.com/widgets/follow_button.4a8202e5fcbfb5ba8d36683841f4d020.en.html#screen_name=${config.twitter_user}&width=67&height=22&show_count=false&show_screen_name=true`"></iframe>
<iframe width="120" height="22" :src="`https://widget.weibo.com/relationship/followbutton.php?btn=light&style=1&uid=${config.weibo_uid}&width=67&height=22&language=zh_cn`"></iframe>
</div>
</div>
<div>
<h4>分享文章</h4>
<div>
<span class="icon twitter-icon" @click="openShare('twitter', this)"></span>
<span class="icon weibo-icon" @click="openShare('weibo')"></span>
</div>
</div>
</div>
<div class="hr"></div>
<div id="comments"></div>
</div>
<div class="right">
<div id="toc"></div>
<div id="search" class="pure-form">
<fieldset>
<input id="search_q" @keyup.enter="searchBlog($('#search_q').value)">
<button @click="searchBlog($('#search_q').value)" class="pure-button pure-button-primary">搜索</button>
</fieldset>
</div>
</div>
</div>
<button class="button is-primary" onclick="window.scroll(0, 10)" id="up">Up</button>
<button class="button is-primary" onclick="window.scrollTo(0,document.body.scrollHeight)" id="down">Down</button>
</div>
<template id="tree-folder">
<ul class="pure-menu-list" v-if="show">
<li class="pure-menu-item" v-for="(file,index) in nodes" :key="file.path">
<a v-if="file.type==='dir'" :type="file.type" @click="openFolder(file)" class="folder">{{file.name}}
</a>
<a v-else :type="file.type" class="file" :href="('/'+file.path).replace(/^\/post\b/, '/b').slice(0,-3)">{{file.name.slice(0,-3)}} </a>
<tree-folder v-if="file.nodes" :show="file.show" :nodes="file.nodes"></tree-folder>
</li>
</ul>
</template>
<template id="md">
<div id="content" v-html="marked(md)"></div>
</template>
<script src="/b/../a/js/blog2.js"></script>
</body>
</html>
