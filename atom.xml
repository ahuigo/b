<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Ahuigo 的网络日志</title>
<link href="https://ahuigo.github.io/b/atom.xml" rel="self" type="application/atom+xml"/>
<updated>2019-02-21T11:07:42Z</updated>
<subtitle>ahuigo's Blog</subtitle>
<entry xml:base="https://ahuigo.github.io">
<title>shell proxy tool</title>
<link href="/b/net/net-proxy-tool" rel="alternate" type="text/html"/>
<updated>2019-02-21T00:00:00Z</updated>
<summary/>
<published>2019-02-21T00:00:00Z</published>
<content># Android
HowTo: Proxy Non-Proxy-Aware Android Applications through Burp
http://blog.dornea.nu/2014/</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>net-socks</title>
<link href="/b/net/net-proxy-socks" rel="alternate" type="text/html"/>
<updated>2019-02-21T00:00:00Z</updated>
<summary/>
<published>2018-09-28T00:00:00Z</published>
<content># socks 协议
SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKetS"的缩写

1. 当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>各种语言的fiddle</title>
<link href="/b/c/ops-fiddle" rel="alternate" type="text/html"/>
<updated>2019-02-21T00:00:00Z</updated>
<summary/>
<published>2018-08-27T00:00:00Z</published>
<content># 各种语言的fiddle
各种语言的fiddle
1. js:
    https://ahuigo.github.io/a/demo/fiddle/fiddle.html # 加上`data:te</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Copy List with Random Pointer</title>
<link href="/b/algorithm/list-copy" rel="alternate" type="text/html"/>
<updated>2019-02-21T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># Copy List with Random Pointer
复制带随机指针的链表问题：
https://www.kancloud.cn/kancloud/data-structure-and-al</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>求两链表的交点</title>
<link href="/b/algorithm/list-intersection" rel="alternate" type="text/html"/>
<updated>2019-02-21T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># 求两链表的交点
我想有3个方法：
1. 将一个链表首尾相连，然后采用[Floyd 判圈法](/p/algorithm/list-intersection-floyd)
2. 用两个栈遍历链表，然后</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>单链表判圈之Floyd算法</title>
<link href="/b/algorithm/list-intersection-floyd" rel="alternate" type="text/html"/>
<updated>2019-02-21T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 单链表是否有环之龟兔算法(tortoise-hare)
Floyd判圈算法(Floyd Cycle Detection Algorithm), 也叫龟兔算法(tortoise-hare)
![cy</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>tcpdump</title>
<link href="/b/net/net-tcpdump" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># tcpdump
example: https://www.rationallyparanoid.com/articles/tcpdump.html
book:

学术的说，tcpdump是一种嗅探</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>net-socks</title>
<link href="/b/net/net-socks" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2018-09-28T00:00:00Z</published>
<content># Preface

SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKetS"的缩写[1]。

1. 当防火墙后的客户端要访问外部的服务器时，就跟SO</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>brew dev</title>
<link href="/b/mac/mac-brew-dev" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># Preface

# rule
brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>图的路径问题</title>
<link href="/b/algorithm/graph-path" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2019-02-17T00:00:00Z</published>
<content># 图的路径问题
主要包含这么几个问题
1. 最短路径
2. 一笔画问题
    1. 奇顶点（连接的边数量为奇数的顶点）的数目等于0或者2
    2. 如果连通无向图 G 有2k 个奇顶点，那么它</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>shell proxy</title>
<link href="/b/net/net-proxy" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># Android
HowTo: Proxy Non-Proxy-Aware Android Applications through Burp
http://blog.dornea.nu/2014/</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>python watch file</title>
<link href="/b/py/py-file-watch" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2019-02-14T00:00:00Z</published>
<content># python watch file
Some methods: https://stackoverflow.com/questions/182197/how-do-i-watch-a-file-f</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Change ssh port</title>
<link href="/b/net/net-ssh-port" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2019-02-16T00:00:00Z</published>
<content># Change ssh port

1.Config : `$ vi /etc/ssh/sshd_config`, if you wanna support multiple port like 2</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>netcat</title>
<link href="/b/net/net-ncat" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2018-09-28T00:00:00Z</published>
<content># netcat,
[nc](http://www.oschina.net/translate/linux-netcat-command?p=2#comments)

# nc
Netcat 或者叫 </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>防火墙</title>
<link href="/b/net/net-iptables" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># 原理
参考[Iptables防火墙原理详解](http://segmentfault.com/a/1190000002540601)

## netfilter/iptables
Netfilte</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux c socket 编程</title>
<link href="/b/c/c-socket" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2019-02-16T00:00:00Z</published>
<content># Preface
Socket 可以有很多概念：

1. 在TCP/IP 中,"IP + TCP或UDP端口号" 唯一标识网络通讯中的*进程*，"IP+端口号"就被称为socket
2. 在TCP </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>计算机结构</title>
<link href="/b/c/c-os" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2019-02-16T00:00:00Z</published>
<content># Preface

本文描述的是现代的计算机所采用的冯诺伊曼(Von Neumann)结构: CPU(Central Procession Unit) + Memory + Device

# OS</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>深度优先DFS和广度优先BFS</title>
<link href="/b/algorithm/graph-dfs-bfs" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># DFS(Depth First Search) 深度优先搜索
所有的递归函数都可以用基于stack 的循环结构去实现, 这样我们就能直接控制栈的长度。为了具体阐明这个方法，举一个关于[DFS] (</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>如何避免深度递归</title>
<link href="/b/algorithm/3.algo-self-call" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 如何避免深度递归
我们先看看函数与递归的本质：

- 函数调用的本质是: 我们在做一件事过程中，我们发现必须要先完成另外一件事，于是中断当前的工作，并把当前的工作信息保存到栈(stack); 当别</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>go time</title>
<link href="/b/go/19.go-time" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-14T00:00:00Z</published>
<content># tick and after

## timer/ticker, 定时器
`chan time.Time: timer.C = ticker.C`
定时器对象

    timer := time</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>BFPRT 算法</title>
<link href="/b/algorithm/sort-topk" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># Topk 算法之BFPRT算法
基于最大/小堆的TopK 算法复杂度为 $O(n\log n)$

其实还有O(n)的算法 —— BFPRT 基于减治法，采用类似二分法的快排分区减低复杂度。

#</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>查找数组中的中值</title>
<link href="/b/algorithm/sort-topk-kth" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-14T00:00:00Z</published>
<content># 查找数组中的中值
This is a question about find k'th number in an array.

    def find_kth(arr, k):
       </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>android 刷包工具</title>
<link href="/b/net/net-sniffer-android" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-13T00:00:00Z</published>
<content># android 刷包工具
1. tPacketCapture: uses the Android VPN service to intercept packets and capture them</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>combination</title>
<link href="/b/math/math-probability" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># probility
德摩根定律: $(A\cup B)^{C}=A^{C}\cap B^{C}$

概率计算总结
1. 非A	$P(A^{c})=1-P(A)$
2. A或B	$P(A\cup B</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>数学运算符</title>
<link href="/b/math/math-num-operator" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-14T00:00:00Z</published>
<content># 数学运算符
Exponentiation

    a^x读作“a的x次方”或“a的n次幂“。

Power function

    x^n

对数是幂运算的逆运算

## Logarithm</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>rime 鼠须管输入法</title>
<link href="/b/mac/mac-rime" rel="alternate" type="text/html"/>
<updated>2019-02-20T00:00:00Z</updated>
<summary/>
<published>2019-02-20T00:00:00Z</published>
<content># Rime 中的數據文件分佈及作用
除程序文件以外，Rime 還包括多種數據文件。 這些數據文件存在於以下位置：

共享資料夾(不同的系统不一样ni h)

    【中州韻】 /usr/share</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mac 切换到自带的双拼方案</title>
<link href="/b/mac/mac-inputmethod-pinyin" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-13T00:00:00Z</published>
<content># mac 切换到自带的双拼方案
用了10多年的五笔后，还是受不了打字要停顿，于是换回mac 自带的双拼方案（我选择的是小鹅双拼）10.14.2 已经支持了。

开启了一下功能：
1. 小额双拼
2.</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux perf(系统性能分析)</title>
<link href="/b/c/ops-perf" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-14T00:00:00Z</published>
<content># perf
从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。

http://blog.csdn.net/zhangskd/article/d</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>经典排序算法的实现</title>
<link href="/b/algorithm/sort" rel="alternate" type="text/html"/>
<updated>2019-02-16T00:00:00Z</updated>
<summary/>
<published>2013-09-26T00:00:00Z</published>
<content># 经典排序算法实现
常规的几种排序算法, 参考[维基sort](http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>查找数组中的中值</title>
<link href="/b/algorithm/sort-kth" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-02-14T00:00:00Z</published>
<content># 查找数组中的中值
This is a question about find k'th number in an array.

    def find_kth(arr, k):
       </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Analysis of Algorithm</title>
<link href="/b/algorithm/1.time-complex" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2018-09-15T00:00:00Z</published>
<content># Analysis of Algorithm
本文整理下算法的分析方法

##  O/Omega/Thelta 的定义
$Ο$，读音：big-oh、欧米可荣（大写）；表示上界(tightness u</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>数字的分类</title>
<link href="/b/math/math-num" rel="alternate" type="text/html"/>
<updated>2019-02-13T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 数字的分类
- 实数: x 的整数部分[x], 小数部分{x}
    - 整数, Integer: ℕ
        - 正整数, positive:
    - 有理无理:
        </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>哈希</title>
<link href="/b/algorithm/4.algo-hash" rel="alternate" type="text/html"/>
<updated>2019-02-14T00:00:00Z</updated>
<summary/>
<published>2019-01-18T00:00:00Z</published>
<content>
# 哈希函数
1. key 均匀的落到不同的slots
2. key 本身不能影响到hash 的均匀性

## 散列法
### 取模法
hash = key mod m
1. m尽量用质数，不要用$</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Fibonacii and gold(φ)</title>
<link href="/b/math/math-num-fibonacii" rel="alternate" type="text/html"/>
<updated>2019-02-11T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Fibonacii and gold(φ)
Fibonacii/gold 有很多有趣的性质
1. 广义fibonacii 逼近gold 的证明 寻找相邻两项之比不趋于 1.618 的广义 Fibo</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Trie 树</title>
<link href="/b/algorithm/tree-trie" rel="alternate" type="text/html"/>
<updated>2019-02-11T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># Trie 树
通过Trie 建立字典索引（空间为代价）

abc","ab","bd","dda" 建立索引：

    a
        b-&gt;ab
            c-&gt;abc
  </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>trie-filter</title>
<link href="/b/algorithm/tree-trie-filter" rel="alternate" type="text/html"/>
<updated>2019-02-11T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># trie-filter

# php word filter
https://github.com/wulijun/php-ext-trie-filter</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>跳跃表</title>
<link href="/b/algorithm/tree-skiplist" rel="alternate" type="text/html"/>
<updated>2019-02-11T00:00:00Z</updated>
<summary/>
<published>2017-09-26T00:00:00Z</published>
<content># 跳跃表
我们实现redis 的有序集合用什么结构呢？
1. list: 插入的复杂度是O(n)
2. 链表: 查找的复杂度是O(n)

跳跃表(skiplist) 是一种随机化的数据结构，相当于为</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>二叉堆</title>
<link href="/b/algorithm/tree-binheap" rel="alternate" type="text/html"/>
<updated>2019-02-11T00:00:00Z</updated>
<summary/>
<published>2019-02-11T00:00:00Z</published>
<content>https://github.com/bnmnetp/pythonds/blob/master/trees/binheap.py 给了一个最小堆的例子
1. 插入过程是一个向上冒泡pearUp 的过程</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>二叉查找树和红黑树</title>
<link href="/b/algorithm/tree-binary-search-tree" rel="alternate" type="text/html"/>
<updated>2019-02-13T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 二叉查找树
二叉查找树（Binary Search Tree），也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一棵空</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>数据结构之树</title>
<link href="/b/algorithm/tree-" rel="alternate" type="text/html"/>
<updated>2019-02-11T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 数据结构之树

树状图是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

1</content>
</entry></feed>