<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Ahuigo 的网络日志</title>
<link href="https://ahuigo.github.io/b/atom.xml" rel="self" type="application/atom+xml"/>
<updated>2019-02-04T16:43:34Z</updated>
<subtitle>ahuigo's Blog</subtitle>
<entry xml:base="https://ahuigo.github.io">
<title>vim-window</title>
<link href="/b/vim/vim-window" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># Preface


# Window 窗口

## powerline
这是一个增强状态栏的插件

### window title
	setl stl=about\ b.c

## scroll</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>vim 使用之变量</title>
<link href="/b/vim/vim-var" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2019-02-04T00:00:00Z</published>
<content># vim 使用之变量
本文会系统描述vim 的语法，如果想了解具体选项和操作技巧，参考我的vim 笔记

主要参考 [book]:
http://learnvimscriptthehardway.s</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>vim-cmd</title>
<link href="/b/vim/vim-cmd" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># Preface

# autocmd
Syntax:

	:au[tocmd] [group] {event} {pat} [nested] {cmd}
			Add {cmd} to the l</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>vim-cmd-ex</title>
<link href="/b/vim/vim-cmd-ex" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># ex mode

    gQ ex mode
	gv	reselect previouse area

## history mode
:h cmdline-window

    q: Ex </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux nginx 配置</title>
<link href="/b/nginx/nginx-conf" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2019-02-04T00:00:00Z</published>
<content># Preface

# install
 用brew 自动安装吧, 如果需要[extra module](https://github.com/Homebrew/homebrew-nginx/iss</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql lock</title>
<link href="/b/db/mysql-lock" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2019-02-04T00:00:00Z</published>
<content># 总线锁定和缓存一致性
&gt; 基于锁的原子操作 http://ifeve.com/inter-64-ia-32-8-1/
&gt; Java的多线程机制: 缓存一致性和CAS http://www.bdqn</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>go汇编示例</title>
<link href="/b/go/go-asm" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2019-01-23T00:00:00Z</published>
<content>
发现一份汇编示例：
1. Go Assembly 示例 https://colobu.com/goasm/
2. 英文版：https://www.davidwong.fr/goasm/</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql explain 的使用</title>
<link href="/b/db/mysql-index-explain" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># Mysql Explain 的使用

## show index

	show index from table_name;

## explain
用explain 获取mysql 如何quer</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql install</title>
<link href="/b/db/mysql-admin" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2019-02-03T00:00:00Z</published>
<content># Preface
mysql安装

# Install
安装后默认的密码帐号为空:
host=kw.get('host', 'localhost'),
port=kw.get('port', 330</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>wget</title>
<link href="/b/c/ops-wget" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2019-02-03T00:00:00Z</published>
<content># ftp

    wget -r --user="user@login" --password="password" ftp://server.com/
    wget -r ftp://use</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux系统IO</title>
<link href="/b/c/c-io" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2019-02-03T00:00:00Z</published>
<content># Preface
c语言的标准I/O操作实际上是调用的系统内核IO.

# 标准输出的低层实现
以汇编的hello world 为例

	.data					# section declaratio</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>c-debug-strace</title>
<link href="/b/c/c-debug-strace" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Preface

# strace
&gt; 请参考: [strace 使用](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>学习 docker</title>
<link href="/b/arch/arch-docker" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 什么是Docker
虚拟机是对硬件的虚拟化(需要Hypervisor这个软件层), 而docker （LXC, linux container）是对操作系统的虚拟化。
1. docker 基于li</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>AI 入门路线</title>
<link href="/b/ai/ai-book" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2019-01-29T00:00:00Z</published>
<content># AI入门 路线
0. 准备：算法与数据结构、高数、线性代数、概率统计
    1. 系统学习：清华邓俊辉老师《数据结构（C++语言版）》（代码全），算法4版(重实践)，算法导论(偏数学证明)
  </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>git hooks</title>
<link href="/b/git/git-hooks" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2014-05-07T00:00:00Z</published>
<content># git hooks
钩子(hooks)是一些在$GIT-DIR/hooks目录的脚本, 在被特定的事件(certain points)触发后被调用。当git init命令被调用后, 一些非常有用的</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>shell 表达式</title>
<link href="/b/c/shell-grammar" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2019-01-23T00:00:00Z</published>
<content># shell 表达式

# Loop

## for

	for a in "$*" ; do echo "$a "; done
	for a in "$@" ; do echo "$a "; do</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>数字的分类</title>
<link href="/b/math/math-num" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 数字的分类
- 实数: x 的整数部分[x], 小数部分{x}
    - 整数, Integer: ℕ
        - 正整数, positive:
    - 有理无理:
        </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>brew</title>
<link href="/b/mac/mac-brew" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># brew
- brew(Homebrew) 是近来极流行的 安装gawk,gsed,macvim等命令的安装工具，所有的包都被安装到/usr/local/Cellar下，然后再以`ln -s` 软</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>go routines</title>
<link href="/b/go/18.go-routines" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># go routines
A goroutine is a `lightweight thread` managed by the Go runtime.

execution of f happe</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>golang 的协程调度</title>
<link href="/b/go/18.go-routines-inner" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># golang 的协程调度
协程是由用户态自己手动去调度的、轻量的上下文切换。
具体到不同的语言，协程有所不同，主要分串行和并行两大类：
1. js、python 的async/await 模型的协</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>五大过程组，十大知识领域</title>
<link href="/b/em/em-" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 五大过程组，十大知识领域
https://www.jianshu.com/p/33dda2e06225

# PM 项目管理(10大)
&gt; 管理制度+(掌握管理方法的)人+管理信息系统
1. 项目</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>关于人工标注的思考</title>
<link href="/b/code/code-manual-annotation" rel="alternate" type="text/html"/>
<updated>2019-02-03T00:00:00Z</updated>
<summary/>
<published>2019-01-22T00:00:00Z</published>
<content># 关于人工标注的思考
当下人工智能发展的如火如荼，很多场景都在利用人工智能做标注，但是标注总有一定的错误率，这种情况下还是要依赖人工做标注修正。而且，AI也需要人工标注的数据做训练。
这是一个低效率</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux yum</title>
<link href="/b/c/ops-yum" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2019-01-23T00:00:00Z</published>
<content># Preface

# os version
check os version:

	cat /etc/*-release

	lsb_release -a
	OS=$(lsb_release -s</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>哈希</title>
<link href="/b/algorithm/4.algo-hash" rel="alternate" type="text/html"/>
<updated>2019-01-23T00:00:00Z</updated>
<summary/>
<published>2019-01-18T00:00:00Z</published>
<content>
# 哈希函数
1. key 均匀的落到不同的slots
2. key 本身不能影响到hash 的均匀性

## 散列法
### 取模法
hash = key mod m
1. m尽量用质数，不要用$</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>AHUI 的认知作业</title>
<link href="/b/life/self-character" rel="alternate" type="text/html"/>
<updated>2019-01-15T00:00:00Z</updated>
<summary/>
<published>2019-01-15T00:00:00Z</published>
<content># AHUI 的认知作业
如果你的朋友时间有限，那么请他们
1. 选择５个他们觉得最能代表你的形容词(不区分正负性)
2. 再选择３-５个他们觉得你可以在这个方面继续成长的形容词（相较而言偏负性的）。</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Node File System API</title>
<link href="/b/ria/node-fs" rel="alternate" type="text/html"/>
<updated>2019-01-13T00:00:00Z</updated>
<summary/>
<published>2019-01-13T00:00:00Z</published>
<content># node 下的文件 API
默认buffer 

## process.argv

    process.argv.forEach(function (val, index, array) {
</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Js 字符串大全</title>
<link href="/b/ria/js-str" rel="alternate" type="text/html"/>
<updated>2019-01-13T00:00:00Z</updated>
<summary/>
<published>2015-03-15T00:00:00Z</published>
<content># Js 字符串大全
字符定义与python 一样, 而且不区分双引号：

    '\x00' == '\u0000'
	'\x31' == "\x31"

	'好' === '\u597D' //</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>js notes</title>
<link href="/b/ria/js-obj" rel="alternate" type="text/html"/>
<updated>2019-01-13T00:00:00Z</updated>
<summary/>
<published>2019-01-13T00:00:00Z</published>
<content># Object

## define

    {toStr(){}, a:1}
    &gt; a=1
    &gt; b={a}
    { a: 1 }

    new cls().property</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>vim 笔记</title>
<link href="/b/vim/vim-notes" rel="alternate" type="text/html"/>
<updated>2019-01-10T00:00:00Z</updated>
<summary/>
<published>2019-01-10T00:00:00Z</published>
<content># vim 笔记
本文是vim 相关的总结，不会有太多的注释 —— 只是方便回顾.

&gt; 使用vim 时建议将key repeat调到最快, 把key delay调到最小
&gt; 很多时候我会用Ctrl+</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>vim-help</title>
<link href="/b/vim/vim-help" rel="alternate" type="text/html"/>
<updated>2019-02-04T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># help 帮助
&gt; Refer to : http://vim.wikia.com/wiki/Learn_to_use_help

之所以我把help放在这里，是因为help实在是太重要了。关于d</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>设计模式</title>
<link href="/b/php/php-pattern" rel="alternate" type="text/html"/>
<updated>2019-01-10T00:00:00Z</updated>
<summary/>
<published>2019-01-10T00:00:00Z</published>
<content># Preface


# composer Pattern
聚合（空心菱形）：schoolClass 可以包含多个Pupil(聚合Pupil)
组合模式(实心菱形): 是聚合组件,组件不可被其它类包</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Redis</title>
<link href="/b/db/redis-" rel="alternate" type="text/html"/>
<updated>2019-01-10T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Redis
redis所有的数据都是redisObject存储的。redisObject来表示所有的key/value数据是比较浪费内存的(为了支持各种数据类型嘛)，还好redis 作者也考虑了很</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>并发模型</title>
<link href="/b/code/code-concurrent-model" rel="alternate" type="text/html"/>
<updated>2019-01-10T00:00:00Z</updated>
<summary/>
<published>2019-01-10T00:00:00Z</published>
<content># 并发模型
廖老师介绍了一本《七周七并发模型》，值得一读。 这本书从最基础的线程和锁模型讲起，介绍了许多非常有用的并发模型：

    通过无变量的函数式编程实现并发，是无锁并发的一种模型；

  </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>求数列中和最大的连续子序列的和</title>
<link href="/b/algorithm/algo-array-max-consecutive-sub" rel="alternate" type="text/html"/>
<updated>2019-01-10T00:00:00Z</updated>
<summary/>
<published>2019-01-09T00:00:00Z</published>
<content># 求数列中和最大的连续子序列的和
&gt; Find max sum of consecutive sequence for an array.

## 问题
给定一个随机的数字序列，要求找出其中和最大的</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>如何避免深度递归</title>
<link href="/b/algorithm/3.algo-self-call" rel="alternate" type="text/html"/>
<updated>2019-01-08T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 如何避免深度递归
我们先看看函数与递归的本质：

- 函数调用的本质是: 我们在做一件事过程中，我们发现必须要先完成另外一件事，于是中断当前的工作，并把当前的工作信息保存到栈(stack); 当别</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>算法分治法(divide and conquer)</title>
<link href="/b/algorithm/2.divide-conquer" rel="alternate" type="text/html"/>
<updated>2019-01-08T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 算法分治法(divide and conquer)
fibonacii 可以用分治法来做，复杂度非常高.$O(2^n)$

## fibonacii numbers: 
fibonacii num</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>动态规划(Dynamic programing, DP)</title>
<link href="/b/algorithm/algorithm-dp" rel="alternate" type="text/html"/>
<updated>2019-01-08T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 动态规划(Dynamic programing, DP)

动态规则(Dynamic programing, DP) 的大体思路是：将一个特定的问题，切割成若干类似的子问题，最后合并子问题的解并得</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>如何避免深度递归</title>
<link href="/b/algorithm/algorithm-self-call" rel="alternate" type="text/html"/>
<updated>2019-01-08T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 如何避免深度递归
我们先看看函数与递归的本质：

- 函数调用的本质是: 我们在做一件事过程中，我们发现必须要先完成另外一件事，于是中断当前的工作，并把当前的工作信息保存到栈(stack); 当别</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>学习下Golang 的反射</title>
<link href="/b/go/17.go-reflect" rel="alternate" type="text/html"/>
<updated>2019-01-08T00:00:00Z</updated>
<summary/>
<published>2019-01-07T00:00:00Z</published>
<content># Golang 的Reflection
Go 的反射有三个基础概念: Types Types, Kinds, and Values. 

## 获取变量反射类型 TypeOf
你可以通过`refTy</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Golang Interfaces</title>
<link href="/b/go/16.go-interface" rel="alternate" type="text/html"/>
<updated>2019-01-07T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Interfaces
Interface：
1. Interface 可以用来模拟泛型，但是是运行时模拟，没有编译时快
1. method 没有 public protecte..., 如果要被其</content>
</entry></feed>