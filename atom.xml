<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Ahuigo 的网络日志</title>
<link href="https://ahuigo.github.io/b/atom.xml" rel="self" type="application/atom+xml"/>
<updated>2018-12-29T19:01:03Z</updated>
<subtitle>ahuigo's Blog</subtitle>
<entry xml:base="https://ahuigo.github.io">
<title>mysql explain 的使用</title>
<link href="/b/db/mysql-index-explain" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># Mysql Explain 的使用

## show index

	show index from table_name;

## explain
用explain 获取mysql 如何quer</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql ddl</title>
<link href="/b/db/mysql-ddl" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># Storage Engines

	mariadb&gt; show engines

mysql 下所有引擎的其表结构保存在`tb_name.frm` 中, 而数据结构在不同的引擎下，保存的文件有所不</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql tddl sequence</title>
<link href="/b/db/mysql-ddl-id" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># 如何生成全局id

1. 单点:
	1. mysql auto_increment
	2. redis incrnx
2. 分布:
	1. stepN: 可以部署N 台mysql, 每台机器生成的</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql 查询</title>
<link href="/b/db/mysql-ddl-crud" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># database/table/column ddl crud

## database

	//create
	&gt; CREATE DATABASE dbName;
	$ mysqladmin cr</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>数据库</title>
<link href="/b/db/db-" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 数据库

## CAP定理（CAP theorem）
CAP定理（CAP theorem), 指出对于一个分布式计算系统来说，不可能同时满足以下三点:

1. 一致性(Consistency) (</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux 之进程</title>
<link href="/b/c/ops-process" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># Preface
本文总结下进程那些事儿

# PCB 进程控制块
linux 中每个进程都是由进程控制块(PCB) 控制的，PCB是一个task_struct 结构体。

- 进程id。系统中每个</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Shell 变量之数据类型</title>
<link href="/b/c/1.shell-var" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Shell 变量之数据类型
## export

	unset PYTHONPATH

## String, 字符串

### count_chars

	echo 'ahui ahui' | g</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>动态规划(Dynamic programing, DP)</title>
<link href="/b/algorithm/algorithm-dp" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 动态规划(Dynamic programing, DP)

动态规则(Dynamic programing, DP) 的大体思路是：将一个特定的问题，切割成若干类似的子问题，最后合并子问题的解并得</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>关于php的调试方法</title>
<link href="/b/php/2014-3-5-php-debug" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2015-09-11T00:00:00Z</published>
<content># PHP 调试方法

## 基本调试方法

### var_dump 与 二分法
相信大家确认问题点最常用的就是 以下函数结合二分法了：

	var_dump($var);

这种做法会导致一些问题</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Redis</title>
<link href="/b/db/redis-" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Redis
redis所有的数据都是redisObject存储的。redisObject来表示所有的key/value数据是比较浪费内存的(为了支持各种数据类型嘛)，还好redis 作者也考虑了很</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql lock</title>
<link href="/b/db/mysql-lock" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># 总线锁定和缓存一致性
&gt; 基于锁的原子操作 http://ifeve.com/inter-64-ia-32-8-1/
&gt; Java的多线程机制: 缓存一致性和CAS http://www.bdqn</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mysql 索引</title>
<link href="/b/db/mysql-index" rel="alternate" type="text/html"/>
<updated>2018-12-29T00:00:00Z</updated>
<summary/>
<published>2018-12-29T00:00:00Z</published>
<content># Index Type
&gt; http://stackoverflow.com/questions/12813363/what-is-the-difference-between-a-candidat</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>跳跃表</title>
<link href="/b/algorithm/ds-skiplist" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2017-09-26T00:00:00Z</published>
<content># 跳跃表
我们实现redis 的有序集合用什么结构呢？
1. list: 插入的复杂度是O(n)
2. 链表: 查找的复杂度是O(n)

跳跃表(skiplist) 是一种随机化的数据结构，相当于为</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>二叉查找树和红黑树</title>
<link href="/b/algorithm/ds-binary-search-tree" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 二叉查找树
二叉查找树（Binary Search Tree），也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一棵空</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>数据结构之树</title>
<link href="/b/algorithm/algorithm-tree" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 数据结构之树

树状图是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

1</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>一个bloom filter 的redis实现</title>
<link href="/b/algorithm/algorithm-bloom-filter" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># 一个bloom filter 的redis实现	
问题:

&gt; 判断uid是否在一个uids集合中。假设uids集合有n=10^7(1k万)，同时假设uid最多10位，那么其值域范围是10^10(</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>安全的帐号设计</title>
<link href="/b/sec/security-account" rel="alternate" type="text/html"/>
<updated>2018-12-20T00:00:00Z</updated>
<summary/>
<published>2018-12-20T00:00:00Z</published>
<content># Preface
帐号设计可以涉及到很多细节，本文主要从安全的角度作一个总结:

1. password 安全
1. sid 的设计
3. 内部Api 授权
4. SSO 单点登录

# passw</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>密码安全与签名安全</title>
<link href="/b/sec/sec-cryptography" rel="alternate" type="text/html"/>
<updated>2018-12-20T00:00:00Z</updated>
<summary/>
<published>2018-12-20T00:00:00Z</published>
<content># Signature, 签名
MAC(Message Authentication Code) 与 hash 的区别: http://stackoverflow.com/questions/2836</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>py-pkg-setuptool</title>
<link href="/b/py/py-pkg-setuptool" rel="alternate" type="text/html"/>
<updated>2018-12-20T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># Preface
https://packaging.python.org/tutorials/packaging-projects/

setuptools 与 disutils
1. distu</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>BFPRT 算法</title>
<link href="/b/algorithm/algo-topk" rel="alternate" type="text/html"/>
<updated>2018-12-20T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content># Topk 算法之BFPRT算法
基于最大/小堆的TopK 算法复杂度为 $O(n\log n)$

其实还有O(n)的算法 —— BFPRT 基于减治法，采用类似二分法的快排分区减低复杂度。

#</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>关于抢票以及12306 的票仓的sku 设计</title>
<link href="/b/news/ticketing-software" rel="alternate" type="text/html"/>
<updated>2018-12-20T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># 为什么抢票这么难?
抢不到票其实太正常了，而且不是你刷的次数多你就有票，而是是你刷得快、带宽大、机器配置好才可能有票。
看看一下数据就知道抢票有多么的疯狂了。
1. 2018.1.12 [1230</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>css 布局</title>
<link href="/b/ria/js-css-layout" rel="alternate" type="text/html"/>
<updated>2018-12-19T00:00:00Z</updated>
<summary/>
<published>2018-03-03T00:00:00Z</published>
<content># CSS 布局
&gt; 参考: http://zh.learnlayout.com/position.html

# display
1. block: This makes the element a</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Dependency Injector(IoC)</title>
<link href="/b/code/code-di-pattern" rel="alternate" type="text/html"/>
<updated>2018-12-19T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># Dependency Injector(IoC)
依赖注入（Dependency Injection）又称控制反转（Inversion of Control）主要用来实现不同模块或类之间的解耦，可</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>吴恩达给你的人工智能第一课</title>
<link href="/b/ai/book-deeplearning" rel="alternate" type="text/html"/>
<updated>2018-12-19T00:00:00Z</updated>
<summary/>
<published>2018-09-26T00:00:00Z</published>
<content>学习观+ 超智能体
https://zhuanlan.zhihu.com/p/27857399

# 吴恩达给你的人工智能第一课
https://mooc.study.163.com/smartSpe</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>egg model</title>
<link href="/b/ria/egg-model" rel="alternate" type="text/html"/>
<updated>2018-12-10T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># egg model
https://eggjs.org/zh-cn/tutorials/sequelize.html

1.config/plugin.js 中引入 egg-sequelize 插</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>人脑学习的本质</title>
<link href="/b/course/1.study" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 学习的本质是什么？
&gt; YJango 在知乎专栏中开了关于机器学习的专栏，本篇是专栏读后有感。

机器学习的本质就是寻找输入(input) 与输出(output)之间关系的过程, 我们的大脑的也是</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>linux</title>
<link href="/b/c/ops-pssh" rel="alternate" type="text/html"/>
<updated>2018-12-10T00:00:00Z</updated>
<summary/>
<published>2018-12-10T00:00:00Z</published>
<content># Preface
在工作中，我们可能会有同步操作多台linux 服务器的需要。过去的做法是用for 循环执行: `ssh $ip &lt; work.sh $1 $2 &amp;`

其实，我们还可以借助以下这些</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>网络扫描器nmap、zmap</title>
<link href="/b/net/net-nmap-zmap" rel="alternate" type="text/html"/>
<updated>2018-12-07T00:00:00Z</updated>
<summary/>
<published>2016-10-10T00:00:00Z</published>
<content># nmap
常见的网络扫描器有 SSS，X-Scan，Superscan等，功能最强大的当然是[Nmap](http://www.aiezu.com/system/linux/linux_nmap_</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Linux Network</title>
<link href="/b/net/net-" rel="alternate" type="text/html"/>
<updated>2018-12-07T00:00:00Z</updated>
<summary/>
<published>2018-12-07T00:00:00Z</published>
<content># linux tool
网络相关的工具有:

	dns: ip 或 ifconfig，dig
	monitor: netstat -lntp 或 ss -plat
	socket: lsof 查看套</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>ifconfig</title>
<link href="/b/net/2.tool-ifconfig" rel="alternate" type="text/html"/>
<updated>2018-12-07T00:00:00Z</updated>
<summary/>
<published>2018-12-07T00:00:00Z</published>
<content>## ifconfig
ifconfig 是用于查看网卡接口的。
对于linux 来说，它会显示网关gateway(route), 而对于mac 它不会显示网关.
不过
1. mac可以使用通过路由表</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>centos网络配置</title>
<link href="/b/net/1.net-config" rel="alternate" type="text/html"/>
<updated>2018-12-07T00:00:00Z</updated>
<summary/>
<published>2018-12-07T00:00:00Z</published>
<content># centos网络配置
网络配置分手动设置，自动获取2种方法

## 设置网络链接ifcfg-eth0

	cat /etc/sysconfig/network-scripts/ifcfg-eth0</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>mac 工具集</title>
<link href="/b/mac/mac-tool" rel="alternate" type="text/html"/>
<updated>2018-12-10T00:00:00Z</updated>
<summary/>
<published>2018-10-10T00:00:00Z</published>
<content># Preface
本文是我所用的mac 工具集大杂烩。

一些mac osx 能做而linux 桌面级OS 目前不能做的事情：

- mac 支持全局readline , 字符编辑的效率非常非常高(</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>test</title>
<link href="/b/c/ops-benchmark" rel="alternate" type="text/html"/>
<updated>2018-12-24T00:00:00Z</updated>
<summary/>
<published>2018-12-24T00:00:00Z</published>
<content># Preface

性能/压力测试的内涵：

	基准/基线测试 base line testing / benchmark testing
	负载测试 load testing
	压力测试 stre</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>tcp/ip 协议</title>
<link href="/b/net/net-tcpip" rel="alternate" type="text/html"/>
<updated>2018-12-19T00:00:00Z</updated>
<summary/>
<published>2011-11-11T00:00:00Z</published>
<content># 互联网协议栈
分为链路层(link), 网络层(Network), 传输层(Transport), 应用层(Application)

应用层
	DHCP DHCPv6 DNS FTP Gophe</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>“第一次”面试</title>
<link href="/b/news/interview" rel="alternate" type="text/html"/>
<updated>2018-12-07T00:00:00Z</updated>
<summary/>
<published>2018-12-06T00:00:00Z</published>
<content>两年多前裸辞，两年以后又裸面，过程还真是尴尬。总结下我的失败之处：
1. 态度太敷衍。上午在雪场，下午才穿着一身的装备就匆匆赶到百度面试，什么也没换，有些不得体。
2. 没有提前准备。话说工作了这么多</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Vue 组件</title>
<link href="/b/ria/vue-component" rel="alternate" type="text/html"/>
<updated>2018-12-06T00:00:00Z</updated>
<summary/>
<published>2018-07-15T00:00:00Z</published>
<content># Vue 组件

    &lt;div id="app-7"&gt;
    &lt;ol&gt;
        &lt;todo-item v-for="item in groceryList" v-bind:todo="</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>Vue Cli 使用</title>
<link href="/b/ria/vue-cli" rel="alternate" type="text/html"/>
<updated>2018-12-06T00:00:00Z</updated>
<summary/>
<published>2018-10-04T00:00:00Z</published>
<content># Vue Cli 使用
Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：

1. 通过 @vue/cli 搭建交互式的项目`脚手架`: `vue create`
2. 通过 </content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>js charts</title>
<link href="/b/ria/js-chart" rel="alternate" type="text/html"/>
<updated>2018-12-06T00:00:00Z</updated>
<summary/>
<published>2018-12-06T00:00:00Z</published>
<content># Preface
http://socialcompare.com/en/comparison/javascript-graphs-and-charts-libraries

# chartjs
h</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>风险与质量管理</title>
<link href="/b/em/em-risk-quality" rel="alternate" type="text/html"/>
<updated>2018-12-06T00:00:00Z</updated>
<summary/>
<published>2018-12-06T00:00:00Z</published>
<content># 风险管理(Project Risk management)
风险管理是： 为最好地达到项目目标，参与者通过风险识别、风险分析、风险评估，并以此为基础合理地*使用多种管理方法、技术和手段*对项目活动</content>
</entry><entry xml:base="https://ahuigo.github.io">
<title>写论文要用到的网站</title>
<link href="/b/em/em-paper" rel="alternate" type="text/html"/>
<updated>2018-12-06T00:00:00Z</updated>
<summary/>
<published>2018-09-27T00:00:00Z</published>
<content># 写论文要用到的网站
## 参考文献格式生成
https://www.bigan.net/reference/

## 查重
http://www.paperyy.com/ 和
http://www</content>
</entry></feed>